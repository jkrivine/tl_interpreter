# 14/2/2020
## Should sources always be collectable?
A position contains deposits. Those deposits can be emptied through a reduction
or through a 'collection', which is a form of garbage collection. As of now,
'collectable' is defined as 'source with no next, or dead'. Is it a problem for
a source to be collectable at any time? If `A` has a position `v` to sell (with
`v` attached to a source `u` in buyer position), then buyer `B` is not
particularly at risk: either `A` cannot pull on `v`, and `B` is safe, or `A`
can pull, and `B` is unsafe whether source have to be 'killed' or not before
they become 'collectable'.


## Can relative times be salvaged by triggered timers?
We are interested in a backward condition that can express 'from time of sale
of token v + d, to...'. We suppose that the seller (`A`) has an incentive to
start the timer as early as possible, the buyer as late as possible.  Assuming
the dex address D is known advance, the timer could say: 'I can be triggered
when `ownerOf(v)` is any address != `D`'. At the time when `B` sees `v`, `v` is
owned by `D`. If `B` trusts `D`, it knows `D` will not attack by transferring
`v` to some address `D'`. So `B` can safely buy the token, and `A` is then free
to trigger the timer.

# Possible states for positions
For a position pos, here are the possible states of pos depending on
whether `tl.next pos`, `tl.dead pos`, and `tl.segments pos` are defined or not.
Whether a position `pos` is a tl source is tested by `tl.source = pos`.

  Next   Dead  Segment     Status

   ✔      ✗      ✔         alive with a next

   ✗      ✔      ✗         dead

   ✗      ✗      ✗         alive without a next

   ✔      ✔      ✔         (unreachable)

   ✗      ✗      ✔         (unreachable)

   ✗      ✔      ✔         (unreachable)

   ✔      ✔      ✗         (unreachable)

   ✔      ✗      ✗         (unreachable)
